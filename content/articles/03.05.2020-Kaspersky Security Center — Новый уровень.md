На Хабре уже были пару заметок о автоматизации Kaspersky Security Center(KSC)

[Здесь](https://habr.com/ru/post/278209/) и [Здесь](https://habr.com/ru/sandbox/89069/)

Сегодня же я предлагаю окунуться чуть глубже и перейти на новый уровень Использовать: KSC Open API для Kaspersky Security Center 10+.

Для мониторинга состояния, распределения новых автоматизированных рабочих мест по группам, генерировать отчеты приходилось использовать Консоль управления, она обладает обширным функционалом, но скорость ее работы оставляет желать лучшего.

И появления поддержки Open API было как глоток свежего воздуха и сразу же было принято решение использовать данное решение, и как обычно на любимом языке программирования [Go](https://golang.org/) была написана библиотека позволяющая получать доступ к серверу KSC используя предоставляемый им API.

Для использования пакета в своем проекте нам как обычно нужно его получить:

`go get -u github.com/pixfid/go-ksc/kaspersky`

Импортируем пакет в созданный проект.

```go
import (
    "github.com/pixfid/go-ksc/kaspersky"
)
```

Создаем новый клиент для работы с сервером KSC
``` go
func main() {
    ctx := context.Background()
        cfg := kaspersky.Config { //Конфиг для подключения к серверу
    		  Username: "login",
    		  Password: "password",
    		  Server: fmt.Sprintf(`https://%s:%s`, "ip", "port"),
        }
    
    client := kaspersky.New(cfg) //создание нового клиента
    client.KSCAuth(ctx) //авторизация
}
```

Авторизация проста, `POST` запрос на endpoint `/api/v1.0/login`, с установкой заголовков запроса:

`Authorization`  : `KSCBasic user=base64(login),pass=base64(pass)`
`X-KSC-VServer`  : `x`
`Content-Length` : `2`

В случае успеха сервер вернет: `{}`

Запросы к северу могут быть как асинхронные так и синхронные, на некоторые запросы сервер может возвращать данные, строку `accessor` идентификатор коллекции по которому можно получить информацию о коллекции, либо строку `requestId` идентификатор асинхронной операции которы используется для проверки статуса операции.

Для примера несколько запросов и пример информации возвращаемый сервером:

Прошу простить меня за код\стиль некоторые вещи можно было наверно описать более красиво но имееем что имеем буду рад любым предложения по улушению и изменению, так как надеюсь пакет пригодится, а не останется пылиться на github.

Пример запрос на получение списка всех групп:

```
func GetAllGroups(ctx context.Context, client *kaspersky.Client) *FullGroupsInfos {
	groups := &FullGroupsInfos{} // структура описывающая массив групп.

	groupParam := kaspersky.HGParams{
		WstrFilter: `
		(&
			(!"KLGRP_CHLDHST_CNT" = 0)
			(!"grp_from_unassigned" = true)
		)`,
		VecFieldsToReturn: []string{
			"id",
			"name",
			"grp_full_name",
			"creationDate",
			"KLGRP_CHLDHST_CNT",
			"KLSRV_HSTSTAT_CRITICAL",
			"KLSRV_HSTSTAT_WARNING",
		},
		PParams: kaspersky.PParams{
			KlsrvhSlaveRecDepth:    0,
			KlgrpFindFromCurVsOnly: true,
		},
		LMaxLifeTime: 100,
	}

	accessor, _, _ := client.HostGroup.FindGroups(ctx, groupParam) //получение идентификатора коллекции
	count, _, _ := client.ChunkAccessor.GetItemsCount(ctx, accessor.StrAccessor) //получение количества элементов в колекции 
	
	_, _ = client.ChunkAccessor.GetItemsChunk(ctx, kaspersky.ItemsChunkParams{
		StrAccessor: accessor.StrAccessor,
		NStart:      0,
		NCount:      count.Int,
	} , groups) //запрос на получение данных коллекции
	client.ChunkAccessor.Release(ctx, accessor.StrAccessor) //освобождение коллекции
	
	return groups
}

```

Старался не привязываться к структуре ответом сервера, API все еще находится в разработке у лаборатории Касперского по этой причине часть методов возвращает сырые данные `[]byte`, либо принимает пользовательский `inteface{}` в качестве запроса и возвращаемого значения.

Ответ сервера на запрос:

``` json
{
  "pChunk" : {
    "KLCSP_ITERATOR_ARRAY" : [
      {
        "type" : "params",
        "value" : {
          "KLGRP_CHLDHST_CNT" : 1,
          "creationDate" : {
            "type" : "datetime",
            "value" : "2020-03-13T18:48:43Z"
          },
          "grp_full_name" : "Управляемые устройства/Broken/",
          "id" : 160,
          "name" : "Broken"
        }
      }
    ]
  },
  "PxgRetVal" : 1
}

```

Пример получения списка задач на хосте:


``` go
ts, _, _ := client.Tasks.GetAllTasksOfHost(ctx, "domain.name", "d7f6c44c-6743-416d-81b3-343e464f1ec9")
```
`d7f6c44c-6743-416d-81b3-343e464f1ec9 уникальный идентификатор объекта, присваевается сервером KSC`

Ответом будет массив идентификаторов задач:
```{
	"PxgRetVal": ["101", "117", "118", "192"]
}`

Используя которые можно манипулировать задачами(Запускать, Удалять, Останавливать) используя предоставляемые пакетом функции.
 ```go
func (ts *Tasks) SuspendTask(ctx context.Context, strTask string) ([]byte, error)
func (ts *Tasks) ResumeTask(ctx context.Context, strTask string) ([]byte, error)
func (ts *Tasks) RunTask(ctx context.Context, strTask string) ([]byte, error)
func (ts *Tasks) DeleteTask(ctx context.Context, strTask string) ([]byte, error)
 ```
 
-------
В пакете описаны не все возможности API, некоторые методы могу не работать на KSC 10, и могут изменится на KSC 12.

Библиотека будет жить на [GitHub](https://github.com/pixfid/go-ksc)

Буду признателен за отзывы и предложения в продолжении развития проекта.
Cпасибо.